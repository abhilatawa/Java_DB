import java.sql.*;import java.util.HashMap;import java.util.List;import java.util.Map;public class OrderTransactions implements orderControl {    private Statement statement;    /**     * @param customerName     * @param orderId     * @param credit     * @return true if the credit is applied against the product for the customer     */    @Override    public boolean applyCredit(String customerName, int orderId, double credit) {        Connection connection = null;        PreparedStatement preparedStatement = null;        try {            //making DB connection            connection = databaseTester.getDatabaseConnection();            UseDB(connection);            // Fetching the customer ID from the customer name            int cust_id = getCustomerID(customerName);            // if customer not found in the Database            if (cust_id == -1) {                return false;            }            // inserting values into the StoreCrerdits table            String sql = "INSERT INTO StoreCredits (customer_id, credit_amount) VALUES (?, ?)";            preparedStatement = connection.prepareStatement(sql);            preparedStatement.setInt(1, cust_id);            preparedStatement.setDouble(2, credit);            // executing the query            int rowsAffected = preparedStatement.executeUpdate();            return rowsAffected > 0;        } catch (SQLException e) {            e.printStackTrace();            return false;        } finally {            // Close the PreparedStatement in the finally block            try {                if (preparedStatement != null) {                    preparedStatement.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }    /**     * @param name     * @return the CutomerID from the customer name     */    public Integer getCustomerID(String name) {        Connection connection = databaseTester.getDatabaseConnection();        UseDB(connection);        String sql = "SELECT customer_id FROM customers WHERE first_name = ?";        try {            PreparedStatement preparedStatement = connection.prepareStatement(sql);            preparedStatement.setString(1, name);            ResultSet result = preparedStatement.executeQuery();            while (result.next()) {                return result.getInt(1);            }        } catch (Exception e) {            e.printStackTrace();            return null;        }        return null;    }    /**     * @param orderId     * @return the customerID for the customers if they have the order ID     */    public Integer customerswithorderID(int orderId) {        Connection connection = databaseTester.getDatabaseConnection();        UseDB(connection);        String sql = "SELECT customer_id FROM orders WHERE order_id = ?";        try {            PreparedStatement preparedStatement = connection.prepareStatement(sql);            preparedStatement.setInt(1, orderId);            ResultSet result = preparedStatement.executeQuery();            while (result.next()) {                return result.getInt(1);            }        } catch (Exception e) {            e.printStackTrace();            return null;        }        return null;    }    /**     * @param customerName     * @param payment     * @param orderId     * @param receivingStaff     * @return true if the payment is made against the     * order for the customer and data is stored successfully into the new table     */    public boolean payOrder(String customerName, double payment, List<Integer> orderId, String receivingStaff) {        Connection connection = null;        PreparedStatement preparedStatement = null;        try {            connection = databaseTester.getDatabaseConnection();            UseDB(connection);            int customerId = getCustomerID(customerName);            if (customerId == -1 || orderId.isEmpty()) {                return false;            }            // Loop through the list of order IDs and process payments            for (int oi : orderId) {                // Check if the order is unpaid                if (!isOrderUnpaid(connection, oi)) {                    // Order is already paid, skip processing                    continue;                }                // Process payment for the order                String sql = "INSERT INTO Payments (customer_id, order_id, payment_amount, payment_date, receiving_staff) VALUES (?, ?, ?, NOW(), ?)";                preparedStatement = connection.prepareStatement(sql);                preparedStatement.setInt(1, customerId);                preparedStatement.setInt(2, oi);                preparedStatement.setDouble(3, payment);                preparedStatement.setString(4, receivingStaff);                int rowsAffected = preparedStatement.executeUpdate();                if (rowsAffected > 0) {                    // Update payment_status in Orders table                    updatePaymentStatus(connection, oi);                } else {                    // Payment failed for this order                    return false;                }            }            return true; // All payments successful        } catch (SQLException e) {            e.printStackTrace();            return false;        } finally {            // Close resources in the finally block            try {                if (preparedStatement != null) {                    preparedStatement.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }    /**     * @param connection     * @param orderId     * @return true is the order is not paid already which is denoted by the 0 and is default value     * @throws SQLException     */    private boolean isOrderUnpaid(Connection connection, int orderId) throws SQLException {        String query = "SELECT payment_status FROM orders WHERE order_id = ?";        try (PreparedStatement statement = connection.prepareStatement(query)) {            statement.setInt(1, orderId);            try (ResultSet resultSet = statement.executeQuery()) {                return resultSet.next() && resultSet.getInt("payment_status") == 0;            }        }    }    /**     * @param connection     * @param orderId     * @throws SQLException This method is used to update the payment status field in the payments table     *                      whenever the payment is made it changes the payment status to 1     */    private void updatePaymentStatus(Connection connection, int orderId) throws SQLException {        String updateQuery = "UPDATE orders SET payment_status = 1 WHERE order_id = ?";        try (PreparedStatement updateStatement = connection.prepareStatement(updateQuery)) {            updateStatement.setInt(1, orderId);            updateStatement.executeUpdate();        }    }    /**     * @param orderId     * @param reason     * @param receivingStaff     * @param products     * @param quantity     * @return true if the item is returned successfully and data is stored in the returns table     */    @Override    public boolean returnItem(int orderId, String reason, String receivingStaff, List<String> products, List<Integer> quantity) {        Connection connection = null;        PreparedStatement preparedStatement = null;        try {            connection = databaseTester.getDatabaseConnection();            UseDB(connection);            // Ensure that the order exists and is associated with the customer            int customerId = customerswithorderID(orderId);            if (customerId == -1) {                return false;            }            // Loop through the returned items and process returns            for (int i = 0; i < products.size(); i++) {                String productNameValue = products.get(i);                int quantityReturnedValue = quantity.get(i);                // Process return for each item                String sql = "INSERT INTO Returns (order_id, customer_id, return_date, reason, receiving_staff, product_name, quantity_returned) VALUES (?, ?, NOW(), ?, ?, ?, ?)";                preparedStatement = connection.prepareStatement(sql);                preparedStatement.setInt(1, orderId);                preparedStatement.setInt(2, customerId);                preparedStatement.setString(3, reason);                preparedStatement.setString(4, receivingStaff);                preparedStatement.setString(5, productNameValue);                preparedStatement.setInt(6, quantityReturnedValue);                int rowsAffected = preparedStatement.executeUpdate();                if (rowsAffected <= 0) {                    // Return failed for this item                    return false;                }            }            return true; // All returns successful        } catch (SQLException e) {            e.printStackTrace();            return false;        } finally {            // Close resources in the finally block            try {                if (preparedStatement != null) {                    preparedStatement.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }    /**     * @return a list of all customers who owe us payments for orders and the total     * of all unpaid order values. The customer name is the key to the     * map and the outstanding balance is the value of the map.     */    @Override    public Map<String, Double> outstandingPayments() {        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        try {            // Establish database connection            connection = databaseTester.getDatabaseConnection();            UseDB(connection);            // SQL to get outstanding payments            String getOutstandingPaymentsSQL = "SELECT\n" +                    "    customers.customer_id,\n" +                    "    orders.order_id,\n" +                    "    CONCAT(customers.first_name, ' ', customers.last_name) AS name,\n" +                    "    SUM((order_items.quantity) * (products.list_price * (1 - discount))) AS total_order_value\n" +                    "FROM\n" +                    "    latawa.orders\n" +                    "JOIN\n" +                    "    latawa.customers ON orders.customer_id = customers.customer_id\n" +                    "JOIN\n" +                    "    order_items ON orders.order_id = order_items.order_id\n" +                    "JOIN\n" +                    "    products ON order_items.product_id = products.product_id\n" +                    "WHERE\n" +                    "    orders.payment_status != 1\n" +                    "GROUP BY\n" +                    "    customers.customer_id, orders.order_id, name;\n";            // Prepare statement and execute            preparedStatement = connection.prepareStatement(getOutstandingPaymentsSQL);            resultSet = preparedStatement.executeQuery();            // Create a map to store outstanding payments            Map<String, Double> outstandingPaymentsMap = new HashMap<>();            // Retrieve and store results in the map            while (resultSet.next()) {                String customerName = resultSet.getString("name");                double outstandingBalance = resultSet.getDouble("total_order_value");                outstandingPaymentsMap.put(customerName, outstandingBalance);            }            return outstandingPaymentsMap;        } catch (SQLException e) {            e.printStackTrace();            return null;        } finally {            // Close resources in the finally block            try {                if (resultSet != null) {                    resultSet.close();                }                if (preparedStatement != null) {                    preparedStatement.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }    /**     * @return a list of all customers who have some store credit left     * to redeem on orders. The customer name is the key to the map and the balance of the     * store credit is the value of the map.     */    @Override    public Map<String, Double> storeCredit() {        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        try {            connection = databaseTester.getDatabaseConnection();            UseDB(connection);            String sql = "SELECT " +                    "CONCAT(customers.first_name, ' ', customers.last_name) AS name, " +                    "SUM(sc.credit_amount) AS available_credits " +                    "FROM latawa.customers " +                    "JOIN latawa.StoreCredits sc ON customers.customer_id = sc.customer_id " +                    "GROUP BY customers.customer_id " +                    "HAVING available_credits != 0";            preparedStatement = connection.prepareStatement(sql);            resultSet = preparedStatement.executeQuery();            Map<String, Double> storeCreditMap = new HashMap<>();            while (resultSet.next()) {                String customerName = resultSet.getString("name");                double totalCredit = resultSet.getDouble("available_credits");                storeCreditMap.put(customerName, totalCredit);            }            return storeCreditMap;        } catch (SQLException e) {            e.printStackTrace();            return null;        } finally {            // Close resources in the finally block            try {                if (resultSet != null) {                    resultSet.close();                }                if (preparedStatement != null) {                    preparedStatement.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }    @Override    public Map<String, Double> returnWindow() {        Connection connection = null;        PreparedStatement preparedStatement = null;        ResultSet resultSet = null;        try {            connection = databaseTester.getDatabaseConnection();            UseDB(connection);            String sql = "SELECT\n" +                    "    CONCAT(customers.first_name, ' ', customers.last_name) AS name,\n" +                    "    AVG(DATEDIFF(return_date, orders.order_date)) AS average_days_to_return\n" +                    "FROM\n" +                    "    latawa.orders\n" +                    "        JOIN\n" +                    "    latawa.customers ON orders.customer_id = customers.customer_id\n" +                    "        JOIN\n" +                    "    order_items ON orders.order_id = order_items.order_id\n" +                    "        JOIN\n" +                    "    Returns ON order_items.order_id = Returns.order_id\n" +                    "GROUP BY\n" +                    "    name;";            preparedStatement = connection.prepareStatement(sql);            resultSet = preparedStatement.executeQuery();            Map<String, Double> returnWindow = new HashMap<>();            while (resultSet.next()) {                String customerName = resultSet.getString("name");                double averageDaysToReturn = resultSet.getDouble("average_days_to_return");                returnWindow.put(customerName, averageDaysToReturn);            }            return returnWindow;        } catch (SQLException e) {            e.printStackTrace();            return null;        } finally {            // Close resources in the finally block            try {                if (resultSet != null) {                    resultSet.close();                }                if (preparedStatement != null) {                    preparedStatement.close();                }            } catch (SQLException e) {                e.printStackTrace();            }        }    }    /**     * @param connect this is the method which is used to set the Database everytime the connection is made to the Database     */    private void UseDB(Connection connect) {        try {            statement = connect.createStatement();            statement.execute("use latawa");        } catch (SQLException e) {            e.printStackTrace();        }    }}